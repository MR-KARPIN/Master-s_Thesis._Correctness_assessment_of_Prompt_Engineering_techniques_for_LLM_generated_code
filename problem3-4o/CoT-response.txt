To solve the problem of finding the weighted median node along the path from `uj` to `vj` for each query, we can approach it as follows:

1. **Tree Construction**: Construct the tree using the given edges. Since it's an undirected tree, ensure that you can traverse in both directions.

2. **Path Finding**: For each query, identify the path between `uj` and `vj`. This can be achieved using Depth-First Search (DFS) or Breadth-First Search (BFS) to find the path.

3. **Weight Calculation**: Calculate the total weight of the path and determine half of this weight.

4. **Weighted Median Node**: Traverse the path from `uj` to `vj`, accumulating edge weights until the cumulative weight is at least half of the total path weight. The node where this condition is first satisfied is the weighted median node.

Hereâ€™s a function that implements the solution:

```python
from collections import defaultdict, deque

def build_tree(n, edges):
    tree = defaultdict(list)
    for u, v, w in edges:
        tree[u].append((v, w))
        tree[v].append((u, w))
    return tree

def find_path(tree, start, end):
    # Use BFS to find the path from start to end
    queue = deque([(start, [])])
    visited = set()
    while queue:
        current, path = queue.popleft()
        if current == end:
            return path + [end]
        visited.add(current)
        for neighbor, weight in tree[current]:
            if neighbor not in visited:
                queue.append((neighbor, path + [current]))
    return []

def weighted_median_node(n, edges, queries):
    tree = build_tree(n, edges)
    result = []
    
    for uj, vj in queries:
        path = find_path(tree, uj, vj)
        
        # Calculate total path weight
        total_weight = 0
        edge_weights = []
        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            for neighbor, weight in tree[u]:
                if neighbor == v:
                    total_weight += weight
                    edge_weights.append((v, weight))
                    break
        
        # Find the weighted median node
        half_weight = total_weight / 2
        current_weight = 0
        for node, weight in edge_weights:
            current_weight += weight
            if current_weight >= half_weight:
                result.append(node)
                break
    
    return result

# Example usage
n = 5
edges = [[0, 1, 3], [1, 2, 2], [1, 3, 4], [3, 4, 1]]
queries = [[0, 4], [2, 4]]
print(weighted_median_node(n, edges, queries))
```

### Explanation:
- **Tree Construction**: We use a dictionary of lists to keep track of which nodes are connected and the weight of the edges between them.
- **Path Finding**: We use BFS to find the path between `uj` and `vj`. BFS is suited here as it explores all nodes at the present "depth" level before moving on to nodes at the next depth level.
- **Weighted Median Calculation**: As we traverse the path from `uj` to `vj`, we accumulate the weights and check when the cumulative weight reaches or exceeds half of the total path weight. The corresponding node is then added to the result list.