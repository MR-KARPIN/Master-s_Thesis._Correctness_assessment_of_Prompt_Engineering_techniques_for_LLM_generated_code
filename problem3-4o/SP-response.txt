To address the problem of finding the weighted median node for each query in an undirected, weighted tree, we need to follow these steps:

1. **Parse and Structure the Tree**: Use the given `edges` to build an adjacency list representation of the tree.

2. **Identify Paths and Weights**: For each query, find the path from node `uj` to `vj` and calculate the total weight of this path.

3. **Calculate Weighted Median**: For each path, determine the weighted median node. This node is the first one on the path from `uj` to `vj` where the accumulated path weight is at least half of the total path weight.

4. **Depth-First Search (DFS)**: Use DFS to find paths and calculate weights efficiently.

5. **Answer Queries**: For each query, use the calculated paths and weights to determine and store the weighted median node.

Here is the Python function that implements these steps:

```python
def weightedMedian(n, edges, queries):
    from collections import defaultdict, deque
    
    # Build the graph as an adjacency list
    graph = defaultdict(list)
    for u, v, w in edges:
        graph[u].append((v, w))
        graph[v].append((u, w))
    
    def find_path_and_weights(start, end):
        # Use DFS to find the path and calculate weights
        stack = [(start, -1, 0)]  # (current_node, parent, current_weight)
        parent = {start: None}
        weight_to = {start: 0}
        
        while stack:
            node, par, cur_weight = stack.pop()
            
            for neighbor, weight in graph[node]:
                if neighbor == par:
                    continue
                parent[neighbor] = node
                weight_to[neighbor] = cur_weight + weight
                stack.append((neighbor, node, cur_weight + weight))
                
                if neighbor == end:
                    path = []
                    total_weight = weight_to[end]
                    current = end
                    
                    # Backtrack to find the path from end to start
                    while current is not None:
                        path.append(current)
                        current = parent[current]
                    
                    path.reverse()  # We want the path from start to end
                    return path, total_weight
        
        return [], 0
    
    def find_weighted_median(path, total_weight):
        half_weight = total_weight / 2
        accumulated_weight = 0
        
        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            for neighbor, weight in graph[u]:
                if neighbor == v:
                    accumulated_weight += weight
                    break
            if accumulated_weight >= half_weight:
                return v
        
        return path[-1]  # In case we need to return the last node in the path
    
    ans = []
    for uj, vj in queries:
        path, total_weight = find_path_and_weights(uj, vj)
        median_node = find_weighted_median(path, total_weight)
        ans.append(median_node)
    
    return ans

# Example Usage
n = 5
edges = [[0, 1, 3], [1, 2, 1], [1, 3, 4], [3, 4, 2]]
queries = [[0, 4], [2, 4]]
print(weightedMedian(n, edges, queries))
```

### Explanation:
- **Graph Representation**: We use an adjacency list to represent the tree, which allows easy traversal of nodes and their weights.
- **DFS for Path Finding**: For each query, DFS helps in tracking the path from `uj` to `vj` while calculating the cumulative weights.
- **Weighted Median Calculation**: After determining the full path and total weight, we iterate through the path to find the node where the accumulated weight is at least half of the total path weight.
- **Query Handling**: Each query is processed independently, and the result is stored in the `ans` list.